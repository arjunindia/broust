RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
RefCell { value: <html>
	<head>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<meta>
		<meta>
		<meta>
		<link>
		<link>
		<link>
		<link>
		<link>
		<link>
		<title>
			Drawing to the Screen | Web Browser Engineering
	<body>
		<header>
			<h1>
				Drawing to the Screen
			<a>
				Twitter
			 ¬∑

			<a>
				Blog
			 ¬∑

			<a>
				Patreon
			 ¬∑

			<a>
				Discussions
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<nav>
			<ul>
				<li>
					<a>
						Creating
windows
				<li>
					<a>
						Drawing to the window
				<li>
					<a>
						Laying out
text
				<li>
					<a>
						Scrolling
text
				<li>
					<a>
						Faster
rendering
				<li>
					<a>
						Summary
				<li>
					<a>
						Outline
				<li>
					<a>
						Exercises
		<p>
			A web browser doesn‚Äôt just download a web page; it also has to show
that page to the user. In the 21
			<sup>
				st
			 century, that means a
graphical application. So in this chapter we‚Äôll equip our browser with a
graphical user interface.
			<span>
				<span>
					There are some obscure text-based browsers: I used

					<code>
						w3m
					 as my main browser for most of 2011. I don‚Äôt
anymore.
		<h1>
			Creating windows
		<p>
			Desktop and laptop computers run operating systems that provide

			<em>
				desktop environments
			: windows, buttons, and a mouse. So
responsibility ends up split: programs control their window, but the
desktop environment controls the screen. Therefore:
		<ul>
			<li>
				The program asks for a new window and the desktop environment
actually displays it.
			<li>
				The program draws to its window and the desktop environment puts
that on the screen.
			<li>
				The desktop environment tells the program about clicks and key
presses, and the program responds and redraws its window.
		<p>
			Doing all of this by hand is a bit of a drag, so programs usually use
a 
			<em>
				graphical toolkit
			 to simplify these steps. Python comes with
a graphical toolkit called Tk using the Python package

			<code>
				tkinter
			.
			<span>
				<span>
					The
library is called Tk, and it was originally written for a different
language called Tcl. Python contains an interface to it, hence the
name.
			 Using it is quite simple:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							import
						 tkinter
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						tkinter.mainloop()
		<p>
			Here 
			<code>
				tkinter.Tk()
			 asks the desktop environment to create
a window and returns an object that you can use to draw to the window.
The 
			<code>
				tkinter.mainloop()
			 call enters a loop that looks like
this:
			<span>
				<span>
					This pseudocode may
look like an infinite loop that locks up the computer, but it‚Äôs not.
Either the operating system will multitask among threads and processes,
or the 
					<code>
						pendingEvents
					 call will sleep until events are
available, or both; in any case, other code will run and create events
for the loop to respond to.
		<p>
			<a>
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							while
						<span>
							True
						:
					<span>
						<a>
						<span>
							for
						 evt 
						<span>
							in
						 pendingEvents():
					<span>
						<a>
						        handleEvent(evt)
					<span>
						<a>
						    drawScreen()
		<p>
			Here, 
			<code>
				pendingEvent
			 first asks the desktop environment
for recent mouse clicks or key presses, then 
			<code>
				handleEvent
			
calls your application to update state, and then 
			<code>
				drawScreen
			
redraws the window. This 
			<em>
				event loop
			 pattern is common in many
applications, from web browsers to video games, because in complex
graphical applications it ensures that all events are eventually handled
and the screen is eventually updated.
		<div>
			<p>
				Though you‚Äôre probably writing your browser on a desktop computer,
many people access the web through mobile devices such as phones or
tablets. On mobile devices, there‚Äôs still a screen, a rendering loop,
and most other things discussed in this book.
				<span>
					<span>
						For example, most real
browsers have both desktop and mobile editions, and the rendering engine
code is almost exactly the same for both.
			<p>
				But there are several differences worth noting. Applications are
usually full-screen, with only one application drawing to the screen at
a time. There‚Äôs no mouse and only a virtual keyboard, so the main form
of interaction is touch. There is a concept of a ‚Äúvisual viewport‚Äù not
present on desktop, to accommodate ‚Äúdesktop-only‚Äù and ‚Äúmobile-ready‚Äù
sites, as well as pinch zoom. 
				<span>
					<span>
						Look at the source of this webpage. In the

						<code>
							&lt;head&gt;
						 you‚Äôll see a ‚Äúviewport‚Äù

						<code>
							&lt;meta&gt;
						 tag. This tag tells the browser that the page
supports mobile devices; without it, the browser assumes that the site
is ‚Äúdesktop-only‚Äù and renders it differently, such as allowing the user
to use a pinch-zoom or double-tap gesture to focus in on one part of the
page. Once zoomed in, the part of the page visible on the screen is the
‚Äúvisual viewport‚Äù and the whole documents‚Äô bounds are the ‚Äúlayout
viewport‚Äù. This is kind of a mix between zooming and scrolling that‚Äôs
usually absent on desktop.
				 And screen pixel density is
much higher, but the total screen resolution is usually lower.
Supporting all of these differences is doable, but quite a bit of work.
This book won‚Äôt go further into implementing them, except in some cases
as exercises.
			<p>
				Also, power efficiency is much more important, because the device
runs on a battery, while at the same time the CPU and memory are
significantly slower and less capable. That makes it much more important
to take advantage of GPU hardware, and the slow CPU makes good
performance harder to achieve. Mobile browsers are challenging!
		<h1>
			Drawing to the window
		<p>
			Our browser will draw the web page text to a 
			<em>
				canvas
			, a
rectangular Tk widget that you can draw circles, lines, and text on. For
example, you can create a canvas with Tk like this:
			<span>
				<span>
					You may be familiar with the
HTML 
					<code>
						&lt;canvas&gt;
					 element, which is a similar idea: a 2D
rectangle in which you can draw shapes.
		<div>
			<pre>
				<code>
					<span>
						<a>
						WIDTH, HEIGHT 
						<span>
							=
						<span>
							800
						, 
						<span>
							600
					<span>
						<a>
						window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						canvas 
						<span>
							=
						 tkinter.Canvas(window, width
						<span>
							=
						WIDTH, height
						<span>
							=
						HEIGHT)
					<span>
						<a>
						canvas.pack()
		<p>
			The first line creates the window, as above; the second creates the

			<code>
				Canvas
			 inside that window. We pass the window as an
argument so that Tk knows where to display the canvas. The other
arguments define the canvas‚Äôs size; I chose 800√ó600 because that was a
common old-timey monitor size.
			<span>
				<span>
					This size, called Super Video Graphics Array (SVGA), was
standardized in 1987, and probably did seem super back
then.
			 The third line is a Tk peculiarity, which positions
the canvas inside the window. Tk also has widgets like buttons and
dialog boxes, but our browser won‚Äôt use them: we will need finer-grained
control over appearance, which a canvas provides.
			<span>
				<span>
					This is why desktop
applications are more uniform than web pages: desktop applications
generally use widgets provided by a common graphical toolkit, which
makes them look similar.
		<p>
			To keep it all organized, let‚Äôs put this code in a class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.window 
						<span>
							=
						 tkinter.Tk()
					<span>
						<a>
						<span>
							self
						.canvas 
						<span>
							=
						 tkinter.Canvas(
					<span>
						<a>
						<span>
							self
						.window, 
					<span>
						<a>
						            width
						<span>
							=
						WIDTH,
					<span>
						<a>
						            height
						<span>
							=
						HEIGHT
					<span>
						<a>
						        )
					<span>
						<a>
						<span>
							self
						.canvas.pack()
		<p>
			Once you‚Äôve made a canvas, you can call methods that draw shapes on
the canvas. Let‚Äôs do that inside 
			<code>
				load
			, which we‚Äôll move
into the new 
			<code>
				Browser
			 class:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.canvas.create_rectangle(
						<span>
							10
						, 
						<span>
							20
						, 
						<span>
							400
						, 
						<span>
							300
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_oval(
						<span>
							100
						, 
						<span>
							100
						, 
						<span>
							150
						, 
						<span>
							150
						)
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							200
						, 
						<span>
							150
						, text
						<span>
							=
						<span>
							&quot;Hi!&quot;
						)
		<p>
			To run this code, create a 
			<code>
				Browser
			, call

			<code>
				load
			, and then start the Tk 
			<code>
				mainloop
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							if
						<span>
							__name__
						<span>
							==
						<span>
							&quot;__main__&quot;
						:
					<span>
						<a>
						<span>
							import
						 sys
					<span>
						<a>
						    Browser().load(URL(sys.argv[
						<span>
							1
						]))
					<span>
						<a>
						    tkinter.mainloop()
		<p>
			You ought to see: a rectangle, starting near the top-left corner of
the canvas and ending at its center; then a circle inside that
rectangle; and then the text ‚ÄúHi!‚Äù next to the circle:
		<div>
			<figure>
				<img>
				<figcaption>
					The expected example output with a
rectangle, oval, and text
		<p>
			Coordinates in Tk refer to X positions from left to right and to Y
positions from top to bottom. In other words, the bottom of the screen
has 
			<em>
				larger
			 Y values, the opposite of what you might be used to
from math. Play with the coordinates above to figure out what each
argument refers to.
			<span>
				<span>
					The
answers are in the 
					<a>
						online
documentation
					.
		<div>
			<p>
				The Tk canvas widget is quite a bit more powerful than what we‚Äôre
using it for here. As you can see from 
				<a>
					the tutorial
				, you can
move the individual things you‚Äôve drawn to the canvas, listen to click
events on each one, and so on. I‚Äôm not using those features in this book
because I want to teach you how to implement them.
		<h1>
			Laying out text
		<p>
			Let‚Äôs draw a simple web page on this canvas. So far, our browser
steps through the web page source code character by character and prints
the text (but not the tags) to the console window. Now we want to draw
the characters on the canvas instead.
		<p>
			To start, let‚Äôs change the 
			<code>
				show
			 function from the
previous chapter into a function that I‚Äôll call 
			<code>
				lex
			<span>
				<span>
					Foreshadowing future
developments‚Ä¶
			 which just 
			<em>
				returns
			 the textual
content of an HTML document without printing it:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 lex(body):
					<span>
						<a>
						    text 
						<span>
							=
						<span>
							&quot;&quot;
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 body:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							elif
						<span>
							not
						 in_tag:
					<span>
						<a>
						            text 
						<span>
							+=
						 c
					<span>
						<a>
						<span>
							return
						 text
		<p>
			Then, 
			<code>
				load
			 will draw that text, character by
character:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(
						<span>
							100
						, 
						<span>
							100
						, text
						<span>
							=
						c)
		<p>
			Let‚Äôs test this code on a real webpage. For reasons that might seem
inscrutable
			<span>
				<span>
					It‚Äôs to delay
a discussion of basic typography to the next chapter.
			,
let‚Äôs test it on the 
			<a>
				first chapter of

				<span>
					Ë•øÊ∏∏ËÆ∞
				 or ‚ÄúJourney to the West‚Äù
			, a classic
Chinese novel about a monkey. Run this URL
			<span>
				<span>
					Right click on the link and
‚ÄúCopy URL‚Äù.
			 through 
			<code>
				request
			,

			<code>
				lex
			, and 
			<code>
				load
			. You should see a window with a
big blob of black pixels inset a bit from the top left corner of the
window.
		<p>
			Why a blob instead of letters? Well, of course, because we are
drawing every letter in the same place, so they all overlap! Let‚Äôs fix
that:
		<div>
			<pre>
				<code>
					<span>
						<a>
						HSTEP, VSTEP 
						<span>
							=
						<span>
							13
						, 
						<span>
							18
					<span>
						<a>
						cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(cursor_x, cursor_y, text
						<span>
							=
						c)
					<span>
						<a>
						    cursor_x 
						<span>
							+=
						 HSTEP
		<p>
			The variables 
			<code>
				cursor_x
			 and 
			<code>
				cursor_y
			 point
to where the next character will go, as if you were typing the text with
in a word processor. I picked the magic numbers‚Äî13 and 18‚Äîby trying a
few different values and picking one that looked most readable.
			<span>
				<span>
					In the 
					<a>
						next chapter
					, we‚Äôll replace magic numbers with font
metrics.
		<p>
			The text now forms a line from left to right. But with an 800 pixel
wide canvas and 13 pixels per character, one line only fits about 60
characters. You need more than that to read a novel, so we also need to

			<em>
				wrap
			 the text once we reach the edge of the screen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							if
						 cursor_x 
						<span>
							&gt;=
						 WIDTH 
						<span>
							-
						 HSTEP:
					<span>
						<a>
						        cursor_y 
						<span>
							+=
						 VSTEP
					<span>
						<a>
						        cursor_x 
						<span>
							=
						 HSTEP
		<p>
			The code increases 
			<code>
				cursor_y
			 and resets

			<code>
				cursor_x
			<span>
				<span>
					In
the olden days of typewriters, increasing 
					<em>
						y
					 meant

					<em>
						feed
					ing in a new 
					<em>
						line
					, and resetting 
					<em>
						x
					 meant

					<em>
						return
					ing the 
					<em>
						carriage
					 that printed letters to the
left edge of the page. So ASCII standardizes two separate
characters‚Äî‚Äúcarriage return‚Äù and ‚Äúline feed‚Äù‚Äîfor these operations, so
that ASCII could be directly executed by teletypewriters. That‚Äôs why
headers in HTTP are separated by 
					<code>
						\r\n
					, even though modern
computers have no mechanical carriage.
			 once

			<code>
				cursor_x
			 goes past 787 pixels.
			<span>
				<span>
					Not 800, because we started at
pixel 13 and I want to leave an even gap on both sides.
			
Wrapping the text this way makes it possible to read more than a single
line.
		<div>
			<p>
				Here‚Äôs a widget demonstrating that concept:
			<iframe>
		<p>
			At this point you should be able to load up 
			<a>
				this page
			 in your browser and have it
look about like this:
		<div>
			<p>
				<img>
				<br>
		<p>
			Now we can read a lot of text, but still not all of it: if there‚Äôs
enough text, all of the lines of text don‚Äôt fit on the screen. We want
users to 
			<em>
				scroll
			 the page to look at different parts of it.
		<div>
			<p>
				In English text, you can‚Äôt wrap to the next line in the middle of a
word (without hyphenation at least), but in Chinese that‚Äôs mostly not a
problem. Mostly, but not always! 
				<span>
					ÂºÄÂÖ≥
				 means
‚Äúbutton‚Äù but is composed of 
				<span>
					ÂºÄ
				 ‚Äúon‚Äù and 
				<span>
					ÂÖ≥
				 ‚Äúoff‚Äù. A line break between them would be confusing,
because you‚Äôd read ‚Äúon off‚Äù instead of ‚Äúbutton‚Äù. The 
				<a>
					ICU library
				, used by both Firefox
and Chrome, 
				<a>
					uses
dynamic programming
				 to guess phrase boundaries based on a 
				<a>
					word
frequency table
				.
		<h1>
			Scrolling text
		<p>
			Scrolling introduces a layer of indirection between page coordinates
(this text is 132 pixels from the top of the 
			<em>
				page
			) and screen
coordinates (since you‚Äôve scrolled 60 pixels down, this text is 72
pixels from the top of the 
			<em>
				screen
			). Generally speaking, a
browser 
			<em>
				lays out
			 the page‚Äîdetermines where everything on the
page goes‚Äîin terms of page coordinates and then 
			<em>
				renders
			 the
page‚Äîdraws everything‚Äîin terms of screen coordinates.
			<span>
				<span>
					Sort of. What actually happens
is that the page is first drawn into a bitmap or GPU texture, then that
bitmap/texture is shifted according to the scroll, and the result is
rendered to the screen. 
					<a>
						Chapter 11
					
will have more on this topic.
		<figure>
			<img>
			<figcaption>
				The difference between page and screen
coordinates
		<p>
			Our browser will have the same split. Right now 
			<code>
				load
			
computes both the position of each character and draws it: layout and
rendering. Let‚Äôs instead have a 
			<code>
				layout
			 function to compute
and store the position of each character, and a separate

			<code>
				draw
			 function to then draw each character based on the
stored position. This way, 
			<code>
				layout
			 can operate with page
coordinates and only 
			<code>
				draw
			 needs to think about screen
coordinates.
		<p>
			Let‚Äôs start with 
			<code>
				layout
			. Instead of calling

			<code>
				canvas.create_text
			 on each character, let‚Äôs add it to a
list, together with its position. Since 
			<code>
				layout
			 doesn‚Äôt need
to access anything in 
			<code>
				Browser
			, it can be a standalone
function:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 layout(text):
					<span>
						<a>
						    display_list 
						<span>
							=
						 []
					<span>
						<a>
						    cursor_x, cursor_y 
						<span>
							=
						 HSTEP, VSTEP
					<span>
						<a>
						<span>
							for
						 c 
						<span>
							in
						 text:
					<span>
						<a>
						        display_list.append((cursor_x, cursor_y, c))
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							return
						 display_list
		<p>
			The resulting list of things to display is called a 
			<em>
				display
list
			.
			<span>
				<span>
					The term
‚Äúdisplay list‚Äù is standard.
			 Since 
			<code>
				layout
			 is
all about page coordinates, we don‚Äôt need to change anything else about
it to support scrolling.
		<p>
			Once the display list is computed, 
			<code>
				draw
			 needs to loop
through it and draw each character. Since 
			<code>
				draw
			 does need
access to the canvas, we make it a method on 
			<code>
				Browser
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y, text
						<span>
							=
						c)
		<p>
			Now 
			<code>
				load
			 just needs to call 
			<code>
				layout
			 followed
by 
			<code>
				draw
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						 load(
						<span>
							self
						, url):
					<span>
						<a>
						        body 
						<span>
							=
						 url.request()
					<span>
						<a>
						        text 
						<span>
							=
						 lex(body)
					<span>
						<a>
						<span>
							self
						.display_list 
						<span>
							=
						 layout(text)
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			Now we can add scrolling. Let‚Äôs add a field for how far you‚Äôve
scrolled:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							class
						 Browser:
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							=
						<span>
							0
		<p>
			The page coordinate 
			<code>
				y
			 then has screen coordinate

			<code>
				y - self.scroll
			:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							self
						.canvas.create_text(x, y 
						<span>
							-
						<span>
							self
						.scroll, text
						<span>
							=
						c)
		<p>
			If you change the value of 
			<code>
				scroll
			 the page will now
scroll up and down. But how does the 
			<em>
				user
			 change

			<code>
				scroll
			?
		<p>
			Most browsers scroll the page when you press the up and down keys,
rotate the scroll wheel, drag the scroll bar, or apply a touch gesture
to the screen. To keep things simple, let‚Äôs just implement the down
key.
		<p>
			Tk allows you to 
			<em>
				bind
			 a function to a key, which instructs
Tk to call that function when the key is pressed. For example, to bind
to the down arrow key, write:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						<span>
							__init__
						(
						<span>
							self
						):
					<span>
						<a>
						<span>
							# ...
					<span>
						<a>
						<span>
							self
						.window.bind(
						<span>
							&quot;&lt;Down&gt;&quot;
						, 
						<span>
							self
						.scrolldown)
		<p>
			Here, 
			<code>
				self.scrolldown
			 is an 
			<em>
				event handler
			, a
function that Tk will call whenever the down arrow key is pressed.
			<span>
				<span>
					<code>
						scrolldown
					 is
passed an 
					<em>
						event object
					 as an argument by Tk, but since
scrolling down doesn‚Äôt require any information about the key press
besides the fact that it happened, 
					<code>
						scrolldown
					 ignores that
event object.
			 All it needs to do is increment

			<code>
				y
			 and re-draw the canvas:
		<div>
			<pre>
				<code>
					<span>
						<a>
						SCROLL_STEP 
						<span>
							=
						<span>
							100
					<span>
						<a>
					<span>
						<a>
						<span>
							def
						 scrolldown(
						<span>
							self
						, e):
					<span>
						<a>
						<span>
							self
						.scroll 
						<span>
							+=
						 SCROLL_STEP
					<span>
						<a>
						<span>
							self
						.draw()
		<p>
			If you try this out, you‚Äôll find that scrolling draws all the text a
second time. That‚Äôs because we didn‚Äôt erase the old text before drawing
the new text. Call 
			<code>
				canvas.delete
			 to clear the old text:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							def
						 draw(
						<span>
							self
						):
					<span>
						<a>
						<span>
							self
						.canvas.delete(
						<span>
							&quot;all&quot;
						)
					<span>
						<a>
						<span>
							# ...
		<p>
			Scrolling should now work!
		<div>
			<p>
				Storing the display list makes scrolling faster: the browser isn‚Äôt
doing 
				<code>
					layout
				 every time you scroll. Modern browsers 
				<a>
					take
this further
				, retaining much of the display list even when the web
page changes due to JavaScript or user interaction.
			<p>
				In general, scrolling is the most common user interaction with web
pages. Real browsers have accordingly invested a 
				<em>
					tremendous
				
amount of time making it fast; we‚Äôll get to some more of the ways later
in the book.
		<h1>
			Faster rendering
		<p>
			<a>
			 Applications have to redraw these contents
quickly for interactions to feel fluid,
			<span>
				<span>
					On older systems, applications
drew directly to the screen, and if they didn‚Äôt update, whatever was
there last would stay in place, which is why in error conditions you‚Äôd
often have one window leave ‚Äútrails‚Äù on another. Modern systems use 
					<a>
						compositing
					,
which avoids trails and also improves performance and isolation.
Applications still redraw their window contents, though, to change what
is displayed. 
					<a>
						Chapter 13
					 discusses
compositing in more detail.
			 and must respond quickly to
clicks and key presses so the user doesn‚Äôt get frustrated. ‚ÄúFeel fluid‚Äù
can be made more precise. Graphical applications such as browsers
typically aim to redraw at a speed equal to the refresh rate, or

			<em>
				frame rate
			, of the screen, and/or a fixed 60Hz
			<span>
				<span>
					Most screens today have a
refresh rate of 60Hz, and that is generally considered fast enough to
look smooth. However, new hardware is increasingly appearing with higher
refresh rates, such as 120Hz. It‚Äôs not yet clear if browsers can be made
that fast. Some rendering engines, games in particular, refresh at lower
rates on purpose if they know the rendering speed can‚Äôt keep
up.
			. This means that the browser has to finish all its
work in less than 1/60th of a second, or 16ms, in order to keep up. For
this reason, 16ms is called the 
			<em>
				animation frame budget
			 of the
application.
		<p>
			But this scrolling is pretty slow.
			<span>
				<span>
					How fast exactly seems to depend a lot on your operating
system and default font.
			 Why? It turns out that loading
information about the shape of a character inside

			<code>
				create_text
			 takes a while. To speed up scrolling, we need
to make sure to do it only when necessary (while at the same time
ensuring the pixels on the screen are always correct).
		<p>
			Real browsers have a lot of quite tricky optimizations for this, but
for our browser let‚Äôs limit ourselves to a simple improvement: skip
drawing characters that are offscreen:
		<div>
			<pre>
				<code>
					<span>
						<a>
						<span>
							for
						 x, y, c 
						<span>
							in
						<span>
							self
						.display_list:
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							&gt;
						<span>
							self
						.scroll 
						<span>
							+
						 HEIGHT: 
						<span>
							continue
					<span>
						<a>
						<span>
							if
						 y 
						<span>
							+
						 VSTEP 
						<span>
							&lt;
						<span>
							self
						.scroll: 
						<span>
							continue
					<span>
						<a>
						<span>
							# ...
		<p>
			The first 
			<code>
				if
			 statement skips characters below the
viewing window; the second skips characters above it. In that second

			<code>
				if
			 statement, 
			<code>
				y + VSTEP
			 is the bottom edge of
the character, because characters that are halfway inside the viewing
window still have to be drawn.
		<p>
			Scrolling should now be pleasantly fast, and hopefully close to the
16ms animation frame budget.
			<span>
				<span>
					On my computer, it was still about double that budget, so
there is work to do‚Äîwe‚Äôll get to that in future chapters.
			
And because we split 
			<code>
				layout
			 and 
			<code>
				draw
			, we don‚Äôt
need to change 
			<code>
				layout
			 at all to implement this
optimization.
		<div>
			<p>
				You should also keep in mind that not all web page interactions are
animations‚Äîthere are also discrete actions, such as mouse clicks.
Research has shown that it usually suffices to respond to a discrete
action in 
				<a>
					100ms
				‚Äîbelow
that threshold, most humans are not sensitive to discrete action speed.
This is very different than interactions such as scroll, where speed
less than 60Hz or so is quite noticeable. The difference between the two
has to do with the way the human mind processes movement (animation)
versus discrete action, and the time it takes for the brain to decide
upon such an action, execute it, and understand its result.
		<h1>
			Summary
		<p>
			This chapter went from a rudimentary command-line browser to a
graphical user interface with text that can be scrolled. The browser
now:
		<ul>
			<li>
				Talks to your operating system to create a window
			<li>
				Lays out the text and draws it to that window
			<li>
				Listens for keyboard commands
			<li>
				Scrolls the window in response
		<div>
			<p>
				And here is our browser rendering this very web page (it‚Äôs fullly
interactive‚Äîafter clicking on it to focus, you should be able to scroll
with the down arrow):
				<span>
					<span>
						This is the full browser source code, cross-compiled to
JavaScript and running in an iframe. Click ‚Äúrestart‚Äù to choose a new web
page to render, then ‚Äústart‚Äù to render it. Subsequent chapters will
include one of these at the end of the chapter so you can see how it
improves.
			<iframe>
		<p>
			Next, we‚Äôll make this browser work on English text, with all its
complexities of variable width characters, line layout, and
formatting.
		<div>
			<iframe>
			<a>
				Close
		<h1>
			Outline
		<p>
			The complete set of functions, classes, and methods in our browser
should look something like this:
		<div>
			<code>
				<span>
					class
				 URL:

				<code>
					<span>
						def
					 __init__(url)

				<code>
					<span>
						def
					 request()

			<code>
				<span>
					def
				 lex(body)

			<code>
				WIDTH

			<code>
				HEIGHT

			<code>
				HSTEP

			<code>
				VSTEP

			<code>
				SCROLL_STEP

			<code>
				<span>
					def
				 layout(text)

			<code>
				<span>
					class
				 Browser:

				<code>
					<span>
						def
					 __init__()

				<code>
					<span>
						def
					 load(url)

				<code>
					<span>
						def
					 draw()

				<code>
					<span>
						def
					 scrolldown(e)

		<h1>
			Exercises
		<p>
			<em>
				Line breaks
			: Change 
			<code>
				layout
			 to end the current
line and start a new one when it sees a newline character. Increment

			<em>
				y
			 by more than 
			<code>
				VSTEP
			 to give the illusion of
paragraph breaks. There are poems embedded in ‚ÄúJourney to the West‚Äù; now
you‚Äôll be able to make them out.
		<p>
			<em>
				Mouse wheel
			: Add support for scrolling up when you hit the
up arrow. Make sure you can‚Äôt scroll past the top of the page. Then bind
the 
			<code>
				&lt;MouseWheel&gt;
			 event, which triggers when you
scroll with the mouse wheel.
			<span>
				<span>
					It will also trigger with touchpad gestures, if you don‚Äôt
have a mouse.
			 The associated event object has an

			<code>
				event.delta
			 value which tells you how far and in what
direction to scroll. Unfortunately, Mac and Windows give the

			<code>
				event.delta
			 objects opposite sign and different scales, and
on Linux, scrolling instead uses the 
			<code>
				&lt;Button-4&gt;
			 and

			<code>
				&lt;Button-5&gt;
			 events.
			<span>
				<span>
					The 
					<a>
						Tk
manual
					 has more information about this. Cross-platform applications
are much harder to write than cross-browser ones!
		<p>
			<em>
				Resizing
			: Make the browser resizable. To do so, 
			<a>
				pass
the 
				<code>
					fill
				 and 
				<code>
					expand
				 arguments
			 to

			<code>
				canvas.pack
			, call and bind to the

			<code>
				&lt;Configure&gt;
			 event, which happens when the window is
resized. The window‚Äôs new width and height can be found in the

			<code>
				width
			 and 
			<code>
				height
			 fields on the event object.
Remember that when the window is resized, the line breaks must change,
so you will need to call 
			<code>
				layout
			 again.
		<p>
			<em>
				Scrollbar
			: Stop your browser from scrolling down past the
last display list entry.
			<span>
				<span>
					This is not quite right in a real browser; the browser
needs to account for extra whitespace at the bottom of the screen or the
possibility of objects purposefully drawn offscreen. In 
					<a>
						Chapter 5
					, we‚Äôll implement this
correctly.
			 At the right edge of the screen, draw a blue,
rectangular scrollbar. Make sure the size and position of the scrollbar
reflects what part of the full document the browser can see, as in the
figure showing page and screen coordinates. Hide the scrollbar if the
whole document fits onscreen.
		<p>
			<em>
				Emoji
			: Add support for emoji to your browser üòÄ. Emoji are
characters, and you can call 
			<code>
				create_text
			 to draw them, but
the results aren‚Äôt very good. Instead, head to 
			<a>
				the OpenMoji project
			, download the emoji
for 
			<a>
				‚Äúgrinning
face‚Äù
			 as a PNG file, resize it to 16√ó16 pixels, and save it to the
same folder as the browser. Use Tk‚Äôs 
			<code>
				PhotoImage
			 class to
load the image and then the 
			<code>
				create_image
			 method to draw it
to the canvas. In fact, download the whole OpenMoji library (look for
the ‚ÄúGet OpenMojis‚Äù button at the top right)‚Äîthen your browser can look
up whatever emoji is used in the page.
		<p>
			<em>
				about:blank:
			 Currently, a malformed URL causes the browser
to crash. It would be much better to have error recovery for that, and
instead show a blank page, so that the user can fix the error. To do
this, add support for the special 
			<code>
				about:blank
			 URL, which
should just render a blank page, and cause malformed URLs to
automatically render as if they were 
			<code>
				about:blank
			.
		<p>
			<em>
				Alternate text direction
			: Not all languages read and lay out
from left to right. Arabic, Persian and Hebrew are good examples of
right-to-left languages. Implement basic support for this with a
command-line flag to your browser.
			<span>
				<span>
					Once we get to 
					<a>
						Chapter 4
					 you could
write it in terms of the 
					<a>
						<code>
							dir
					
attribute on the 
					<code>
						&lt;body&gt;
					 element.
			
English sentences should still lay out left-to-right, but they should
grow from the right side of the screen (load 
			<a>
				this example
			 in your favorite
browser to see what I mean).
			<span>
				<span>
					Sentences in an actual RTL language should do the opposite.
And then there is vertical writing mode for some east Asian langages
like Chinese and Japanese.
		<nav>
			
  Chapter 2 of 
			<a>
				Web Browser Engineering
			.
  
			<a>
				&lt;
			<a>
				&gt;
		<p>
			Did you find this chapter useful? 
			<button>
				Send us feedback!
		<footer>
			
  &copy; 2018&ndash;2023 
			<a>
				Pavel Panchekha
			 &amp; 
			<a>
				Chris Harrelson
		<script>
		<script>
 }
